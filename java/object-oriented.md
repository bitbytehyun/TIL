# 객체지향이란
## 실제 개념
객체지향이란 프로그래밍 패러다임 중 하나로서, 행동과 상태를 가진 객체로 소프트웨어 동작을 제어하는 방식입니다.
예를 들어 배달 프로세스를 개발할 때, 주문, 배달, 요리, 결제를 하나의 흐름으로 개발하는 것이 아니라, 역할분담을 할 수 있는 고객, 배달부, 요리사, 결제 시스템을 행동과 상태로 가진 객체로 코드를 작성하는 것입니다. 

이를 뒷받침해줄 수 있는 특성이 바로 `캡상추다`로 많이 외우고 있는 네가지가 입니다. 
캡슐화로 객체의 상태와 매서드를 최소화로 공개하여 다른 객체와 원활하게 소통할 수 있도록 하고, 상속으로 부모 클래스의 상태와 행동을 전부 물려받을 수 있고, 추상화로 공통 행동의 패턴을 먼저 정의하여 중국 요리사/일본 요리사로 선택하여 사용할 수 있게 합니다. 또한, 다형성으로 ‘요리한다’라는 하나의 행동에 일본/중국 요리사라는 구현체에 따라 다르게 행동을 제어할 수 있습니다. 

객체지향은 60년의 역사동안 객체지향의 개념과 4가지 특성에 맞는 설계법이 발전되왔는데, 그것이 유명한 `SOLID`라고 볼 수 있습니다. 
`Single Responsibility Principle`은 클래스에 하나의 책임 (행동의 계열)만 주어, 한 객체가 하나의 목적으로만 확장될 수 있도록 설계합니다. (예: User → User, UserRepository, EmailSender). 
`Open Closed Principle`은 매서드의 변경은 최소화 하고, 확장하는 방식으로 개발하고자 합니다. (예: Strategy pattern으로 매서드의 변경 최소화). `Liskov Substitution Principle`은 상속이나 구현 관계가 있다면, 부모 클래스를 자식 클래스로 대체하여도 논리적으로 물리적(컴파일)으로도 전혀 문제가 없게 개발하는 것입니다. (예: is-a관계여서 상속 써도 되는지 재차 확인, 행동 위주로 더 추상화). 
`Interface Segregation Principle`은 클래스는 모든 인터페이스의 구현을 할 수 있을 정도로 인터페이스를 분리시키는 것입니다. (예: class Penguin extends Bird → class Penguin extends Eatable). `Dependency Injection Principle` 은 앞으로 요구사항에 의해 변경될 수 있는 클래스를 클라이언트에서 코드 변경없이 쉽게 교체할 수 있도록 중간에 인터페이스로 매개하는 것입니다. (private KakaoSender sender → private Sender sender)

위의 SOLID 법칙을 더 잘 활용하기 위해 정리된 것이 디자인패턴이라고 볼 수 있습니다. 
팩토리 패턴, 전략 패턴, 탬플릿 메서드 패턴 등이 위 다섯가지 설계 원칙을 더 강화할 수 있습니다.

