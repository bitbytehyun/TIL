# 정규화란
## 실제 개념
정규화는 데이터베이스 설계 시, 데이터의 중복을 최소화하고, 데이터 무결성을 보장하기 위해 테이블을 분해하는 과정입니다. 

정규화를 하지 않으면 다음과 같은 문제가 발생할 수 있습니다. 
* 중복 저장: 여러 테이블에 동일한 정보가 저장되면, 수정 시 일부만 변경되어 데이터가 불일치합니다.
* 이상현상 (Anomaly): 데이터 삽입/갱신/삭제 시, 데이터 무결성이 깨질 수 있습니다.

### 이상현상 예시
강좌와 학생 정보가 하나의 테이블에 함께 저장된 경우를 예시로 들겠습니다. 
| 학생ID | 학생명 | 강좌명 | 강의실  |
| ---- | --- | --- | ---- |
| 1  | 정서현 | 수학  | A101 |
| 2  | 슈 | 영어  | A102 |
| 3  | 캔디 | 수학  | A101 |

1. 삽입 이상: 새로운 강좌를 개설하려고 해도, 수강생이 없으면 학생ID, 학생명을 NULL로 넣어야 합니다. 이로 인해 데이터 품질이 저하됩니다. 
2. 갱신 이상: 수학 강좌의 강의실이 A102로 바뀌었을 때, 해당 강좌를 듣는 모든 행의 강의실을 수정해야 합니다. 일부만 수정 시, 데이터가 불일치합니다.
3. 삭제 이상: 슈 학생을 삭제하면, 영어 강좌 정보까지 모두 사라집니다. 강좌 존재 여부가 학생 등록 여부에 종속됩니다. 
이는 학생(학생ID, 학생명), 강좌(강좌ID, 강좌명, 강의실), 수강(학생ID, 강좌ID) 테이블로 분해하여 이상현상을 방지할 수 있습니다. 

### 분해 과정
정규화의 과정은 다음을 거칠 수 있습니다. 
1. 1정규형: 모든 속성이 원자값만 가져야 합니다.
2. 2정규형: 1정규형을 만족하면서, 기본 키의 일부만 종속된 열을 분리합니다. [부분 함수 종속 제거]
3. 3정규형: 2정규형을 만족하면서, 기본키가 아닌 열에 종속된 열들을 분리합니다. [이행 함수 종속 제거]
4. BCNF: 모든 결정자가 후보키가 되도록 합니다.

### 실무 적용
대부분 3정규형까지 적용 후, 업무에 따라 일부 비정규화를 진행합니다.
정규화가 지나치면 JOIN이 많아져서, 여러 테이블 조회를 위해 디스크 I/O의 가능성이 높아져 조회 성능이 저하될 수 있기 때문입니다. 
쓰기의 경우, 여러 테이블을 동시에 갱신해야 하므로 대량 쓰기 시 부하가 커질 수 있습니다. 


| 상황                   | 설계 방식                    | 예시                                                         |
| -------------------- | ------------------------ | ---------------------------------------------------------- |
| **OLTP** (거래성 시스템)   | 정규화 선호                   | 주문, 결제, 회원, 재고 등 핵심 트랜잭션 테이블                               |
| **OLAP** (분석/집계 시스템) | 비정규화 선호                  | 월별 매출 집계 테이블, 통계용 리포트 테이블                                  |
| **대규모 서비스**          | 핵심 데이터는 정규화, 조회 전용은 비정규화 | `salesHistory`(정규화) + `salesSummaryDaily`(비정규화, 캐싱/리플리케이션) |


### 장단점
**장점**
* 데이터 중복 최소화 → 저장 공간 절약
* 데이터 무결성 유지 → 이상현상 방지
* 구조 명확 → 유지보수 용이
**단점**
* JOIN 증가로 조회 성능 저하 가능
* 쿼리 복잡도 증가
* 대량 쓰기 시 부하 증가  
