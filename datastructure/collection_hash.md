# 해시
## 실제 개념
해시는 값을 찾기 위해 전체를 순회하는 데 O(n)이 걸리는 배열과 다리, 데이터를 고정된 크기의 값으로 매핑하여 인덱스처럼 사용함으로써 검색, 삽입, 삭제를 O(1)의 시간 복잡도로 수행할 수 있는 기법입니다.    
즉, 해시는 **key를 index로 변환하여 빠르게 데이터에 접근할 수 있도록 하는 방법**입니다.    
이 변환을 수행하는 함수가 **해시 함수**인데, 좋은 해시 함수는 다음 조건을 갖춰야 합니다. 
  1. 같은 입력은 항상 같은 값을 반환한다. (결정성)
  1. 해시 값이 고르게 분포된다. (균등성)
  1. 서로 다른 입력은 같은 값을 드물게 갖는다. (충돌 최소화)
  1. 계산 속도가 빠르다.


만약 서로 다른 키가 해시 값을 가질 때 이를 **해시 충돌**이라고 하며, 이를 해결하기 위해 대표적으로 **체이닝** 기법을 사용합니다. 체이닝은 같은 인덱스에 속하는 데이터를 연결 리스트 (Node) 형태로 연결하여 관리하는 방식입니다. 

### HashMap과 HashSet 내부 구조
* HashMap
  * `Node<K, V>[] table` 배열로 구현합니다.
  * 각 배열 요소는 해시 값에 대응되는 버킷 역할을 합니다. 각 버킷에는 해시 충돌이 일어난 `Node`들을 연결 리스트로 저장합니다. (자바 8부터는 충돌이 많을 경우 Red-Black Tree로 저장됩니다.)
  * 하나의 노드는 `hash`, `key`, `value`, `next`(다음 노드를 참조) 필드를 가집니다.
  * 삽입 시, `hash(key)`로 배열 인덱스를 계산하고, 해당 인덱스에 노드를 추가하여 연결합니다.
  * 검색 시, `hash(key)`로 배열 인덱스를 계산하여, 리스트 또는 트리를 순회합니다.
* HashSet
  * 내부적으로 `HashMap`을 사용합니다.
  * 저장할 때, `HashMap`의 key만 역할을 하고, value는 더미 객체로 설정됩니다. 

## 내가 이해한 바
### 해시는 배열의 빠른 인덱스 접근을 일반 데이터에도 적용하려는 시도입니다. 
해시 기법은 정수형 인덱스가 아닌, 데이터(예: 문자열, 객체 등)에도 O(1)의 인덱스 접근을 부여하는 도구입니다.
### 구현은 객체 기반으로 했지만, 논리는 배열 기반입니다.
`HashMap`은 객체지향적으로 보이지만, 내부는 결국 `Node[]` 배열 구조 입니다.
`LinkedList`, `Tree`, `Map` 등 다양한 구조가 배열을 중심으로 확장되고, 이는 성능이 결국 메모리 배치와 접근 방식에 좌우되는 것입니다. 


## 내가 개발할 때 신경쓰는 점
## 개선된 점
