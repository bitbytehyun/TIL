# 트리
## 실제 개념
트리 자료구조도 해시와 마찬가지로 빠르게 탐색하기 위해 등장했습니다.

해시는 평균적으로 O(1)에 가까운 탐색 속도를 가지지만, 정렬되지 않은 상태이기 때문에 범위 검색이나 정렬된 순서의 탐색에는 부적합합니다.
반면, 트리는 O(log n)의 탐색 성능을 가지지만, 항상 정렬된 형태를 유지하기 때문에 정렬 기반의 검색이나 범위 쿼리에 강점이 있습니다.

또한, Java에서는 `HashMap`이나 `HashSet`에서 해시 충돌이 일정 수준 이상 발생하면, 해당 버킷 내부를 연결 리스트에서 트리 구조로 자동 전환합니다.

### TreeMap과 TreeSet 내부 구조
내부적으로 Red-Black Tree라는 균형 이진 탐색 트리(자식이 최대 2개, 정렬)을 사용합니다. 그 중에서도 좌우 균형을 유지하기 위한 Balanced Tree의 일종입니다. 
Red-Black Tree의 주요 규칙은 다음과 같습니다. 
1. 노드는 빨강생 아니면 검정색이다.
2. 루트 노드는 검정색이다
3. 모든 리프는 검정색이다.
4. 빨간 노드의 자식은 검정색이다. (즉, 빨간색은 연속될 수 없다.)
5. 임의의 노드에서 리프까지 가는 모든 경로의 검정 노드 수는 동일하다.
이 규칙 덕분에 트리는 높이의 불균형 없이 정렬을 유지할 수 있습니다.
* 
* TreeMap
  * `Entry<K, V> root`로 루트 노드를 관리합니다. 
  * 각 `Entry`는 `key`, `value`, `left`, `right`, `parent`, `color` 필드를 가집니다.
  * 삽입 시, `Comparable`(또는 `Comparator`)를 통해 이진 탐색으로 위치를 삽입 위치를 찾습니다. 새 노드를 삽입한 뒤, 규칙을 만족시키기 위해 색상 변경, 회전 등 수행합니다.
  * 검색 시, 루트부터 시작하여 트리의 좌우 자식을 따라가며 탐색합니다. 항상 O(log n)의 시간복잡도를 가집니다.
* TreeSet
  * 내부적으로 `TreeMap`을 사용합니다.

## 내가 이해한 바

### 트리 맵과 해시 맵 결정 기준


## 내가 개발할 떄 신경쓰는 점
## 개선된 점
