# JVM 메모리 구조
## 실제 개념
JVM 메모리 구조는 **모든 쓰레드가 공유하는 영역**과 **쓰레드마다 독립적인 영역**으로 나뉩니다.

공유되는 영역에는 클래스 정보를 저장하는 **매서드 영역**과 생성된 객체가 저장되는 **힙 영역**이 있습니다.
* 매서드 영역에는 클래스의 이름, 정적 변수 등 정적 정보가 저장됩니다.
* 힙 영역에는 new 연산자를 통해 생성된 객체들이 저장되며, 동적으로 할당됩니다.

반면, 쓰레드마다 독립적인 영역에는 다음이 있습니다.
* Java Stack: 매서드 호출 시 스택 프레임이 쌓이며, 매서드가 리턴되면 LIFO 방식으로 자연스럽게 제거됩니다.
* PC Register: 현재 실행 중인 명령어의 주소를 저장합니다.

프로그램이 실행되면, JVM의 클래스 로더가 매서드 영역에 클래스 정보들을 적재합니다.
`main()`함수의 실행 흐름에 따라, 힙역역에는 객체가, Java Stack에는 매서드 실행 정보가 쌓입니다.

Java Stack은 매서드가 종료되면서 메모리가 자동으로 회수되지만, 힙 영역은 그렇지 않기 때문에 JVM의 **Garbage Collector**가 사용하지 않는 객체를 찾아서 회수해야 합니다.

객체는 객체 헤더에 필드 데이터 외에, GC 마크, 참조 횟수에 따라 증가하는 age 값을 가집니다.
GC는 참조 그래프를 따라 객체를 탐색하며, age 값이 일정 이상 증가하면 Young Generation에서 Old Generation 영역으로 객체를 이동시킵니다.
* Young Generation이 가득 차면 **Minor GC**가 발생하고,
* Old Generation이 가득 차면, **Major GC**가 발생합니다.

Major GC는 상대적으로 무겁고, STW (Stop-The-World) 시간이 길어질 수 있기 때문에 성능 저하의 원인이 됩니다.
이를 방지하기 위해, 개발자는 major GC가 일어나지 않도록 불필요한 객체의 참조를 빠르게 끊고, 내부 캐시 크기를 조절하는 등 메모리 관리에 주의해야 합니다.
JVM은 GC가 일어나더라도 부하를 줄이기 위해, 다양한 GC 알고리즘을 제공합니다.
* Serial GC: 단일 쓰레드로 동작하고 정지 시간이 길지만, 메모리가 적은 환경에 적합합니다.
* Paralle GC: 멀티 쓰레드로 수행하여 정지 시간을 줄입니다.
* CMS GC (Concurrent Mark-Sweep): 어플리케이션과 병행하여 Major GC를 수행합니다.
* G1 GC (Garbage First): 힙을 작은 영역으로 나누어서, 수집 효울이 높은 영역부터 Major GC를 발생시켜 GC의 부하를 분산시킵니다.

## 내가 이해한 바
### JVM은 하드웨어의 물리적 메모리를 직접 다루지 않고, 추상화된 메모리 구조 위에서 작동합니다.
객체, 클래스, 매서드 실행 상태를 메로리 구획(힙, 스택, 매서드 영역 등)으로 나누어 관리하여, 안정성과 이식성을 확보합니다. 이 구조는 실행 시간, 성능, 오류 발생의 근본 원인을 이해할 수 있는 열쇠입니다. 

### JVM 메모리 구조는 단순한 저장소가 아니라, 자바의 핵심 개념들이 출발하는 기반입니다.
* 힙 영역은 객체가 생성되고 공유되는 공간이기 때문에, 멀티 쓰레드 환경에서의 **동기화(synchronized), 임계 영역, volatile, atomic** 등의 개념이 등장합니다. 또한, 객체는 자동으로 회수되지 않으므로 **GC 이론**에 대한 이해가 필수적입니다.
* 스택 영역은 쓰레드마다 독립적으로 할당되고, 매서드가 종료되면 자동으로 회수되기 때문에 별도의 회수 알고리즘을 고려할 필요는 없습니다.
* 매서드 영역은 클래스의 매타 정보를 저장하는 곳으로, **클래스 로딩, 리플랙션**과 밀접한 관계가 있습니다. 클래스 로더는 리플랙션을 통해 클래스의 구조를 런타임에 해석하고 동적으로 사용하는 기능을 제공합니다.
* 자바는 하나의 프로세스 안에서 여러 쓰레드를 다루기 때문에, **Thread, Runnable, Callable, Future, Completable Future, ThreadPool** 개념이 필요하며, 동시에 **블로킹/논블로킹, 동기/비동기 처리** 개념이 중요해집니다. 이 흐름 속에서 자바는 **io와 nio** 모델을 발전시켜왔습니다.

결국, JVM 메모리 구조는 자바의 메모리 관리, 동시성 처리, 클래스 로딩, io 모델을 이해하기 위한 출발점입니다.


## 내가 개발할 때 신경쓰는 점

## 개선된 점
